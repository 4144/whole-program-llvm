#!/usr/bin/env python
"""
Extract the .llvm_bc section from the provided ELF object and
reassemble it into an actual bitcode file.  The ELF section contains
absolute paths to all of its constituent bitcode files.  This
utility reads the section and links together all of the named
bitcode files.

The environment variable LLVM_LINKER can be used as an alternative
to the --linker option.
"""

import os
import sys
from subprocess import *
from driver.utils import llvmCompilerPathEnv
from driver.popenwrapper import Popen
from driver.utils import elfSectionName

import logging
import pprint
import driver.logconfig
sectionName = '.llvm_bc'
inputFile = sys.argv[1]

# Use objdump on the provided binary; parse out the fields
# to find the given section.  Return the size and offset of
# that section (in bytes)
def getSectionSizeAndOffset(sectionName, filename):
    objdumpCmd = ['objdump', '-h', '-w', filename]
    objdumpProc = Popen(objdumpCmd, stdout=PIPE)

    objdumpOutput = objdumpProc.communicate()[0]
    if objdumpProc.returncode != 0:
        logging.error('Could not dump %s' % filename)
        sys.exit(-1)

    for line in [l.decode() for l in objdumpOutput.splitlines()] :
        fields = line.split()
        if len(fields) <= 7:
            continue
        if fields[1] != sectionName:
            continue
        try:
            idx = int(fields[0])
            size = int(fields[2], 16)
            offset = int(fields[5], 16)
            return (size, offset)
        except ValueError:
            continue

    # The needed section could not be found
    raise Exception('Could not find "{0}" ELF section in "{1}"'.format(
                    sectionName,
                    filename)
                   )

# Read the entire content of an ELF section into a string
def getSectionContent(size, offset, filename):
    with open(filename, mode='rb') as f:
        f.seek(offset)
        c = f.read(size).decode()
        # The linker pads sections with null bytes; our real data
        # cannot have null bytes because it is just text.  Discard
        # nulls.
        return c.replace('\0', '')

def main(args):
    import argparse

    llvmLinker = os.getenv(llvmCompilerPathEnv)
    if not llvmLinker:
      llvmLinker=''
    llvmLinker = os.path.join(llvmLinker, 'llvm-link')

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("wllvm_binary", help="A binary produced by wllvm/wllvm++")
    parser.add_argument("--linker","-l", help='The LLVM bitcode linker to use. Default "%(default)s"',
                        default=llvmLinker)
    parsedArgs = parser.parse_args()

    inputFile = parsedArgs.wllvm_binary
    llvmLinker= parsedArgs.linker

    (sectionSize, sectionOffset) = getSectionSizeAndOffset(elfSectionName, inputFile)
    if sectionSize == 0:
        sys.stderr.write('%s is empty' % elfSectionName)
        sys.exit(-1)

    content = getSectionContent(sectionSize, sectionOffset, inputFile)
    fileNames = content.split('\n')

    logging.debug('Found the following file names from ELF header:\n' + pprint.pformat(fileNames))
    linkCmd = [ llvmLinker, '-o', '{0}.bc'.format(inputFile)]
    linkCmd.extend([x for x in fileNames if x != ''])
    linkProc = Popen(linkCmd)

    exitCode = linkProc.wait()

    sys.exit(exitCode)

if __name__ == '__main__':
    sys.exit(main(sys.argv))

